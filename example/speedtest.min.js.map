{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","client/speedtest.js","speedtest.js","client/event-dispatcher.js","client/modules/bandwidth.js","client/modules/http.js","client/modules/latency.js","client/timing.js","client/utilities.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","SpeedTest","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"LatencyModule","BandwidthModule","options","_modules","_setModule","fn","prototype","name","isRequesting","modules","requesting","hasOwnProperty","object","_this","on","./modules/bandwidth","./modules/latency",2,"EventDispatcher","_events","eventType","callback","events","indexOf","push","off","eventIndex","splice","trigger","extraParameters","context","returnValue","forEach","value","apply",3,"HttpModule","Timing","Utilities","loadingType","validLoadingTypes","extend","dataSize","upload","download","multiplier","_loadingType","_intendedEnd","_isRestarting","_lastLoadedValue","_speedRecords","_avgSpeed","_requestID","_progressID","_timingLabels","start","progress","end","measure","_initBandwidthConfig","Object","create","_options","reqID","labels","blob","Blob","ArrayBuffer","type","_newRequest","size","_sendRequest","abort","_abort","eventsPrefix","mark","event","_progress","_timeout","_end","progressID","markLabel","loaded","instantSpeed","avgMeasure","avgSpeed","instantMeasure","../timing","../utilities","./http",4,"moduleName","endpoint","delay","_moduleName","_xhr","_lastURLToken","_requestingOverridden","_requesting","_initHttpConfig","loadstart","loadend","httpMethod","queryParams","console","warn","xhr","XMLHttpRequest","validHttpMethods","Date","getTime","url","keys","param","encodeURIComponent","open","timeout","readyState","OPENED","eventTypes","addEventListener","arguments","data","send","_getTimingEntry","setTimeout","lastURLToken","entries","performance","getEntriesByType","filter","entry","_setRequesting","../event-dispatcher",5,"_requestsLeft","_latencies","_initLatencyConfig","supportsResourceTiming","_nextRequest","latency","secureConnectionStart","connectStart","connectEnd","HEADERS_RECEIVED","_calculate","latencies","isThereAnyZeroLatency","avgLatency","reduce","b","join",6,"staticScope","_marks","_measures","_support","userTiming","resourceTiming","timing","label","support","marks","now","measureLabel","markLabelA","markLabelB","measures","getEntriesByName","duration",7,"destination","source","JSON","parse","stringify","key"],"mappings":"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","file":"speedtest.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar LatencyModule = require('./modules/latency'),\n    BandwidthModule = require('./modules/bandwidth');\n\nvar SpeedTest = module.exports = function(options) {\n    // Initialize the modules\n    this._modules = {};\n    this._setModule('latency', new LatencyModule(options))\n        ._setModule('upload', new BandwidthModule('upload', options))\n        ._setModule('download', new BandwidthModule('download', options));\n};\n\nvar fn = SpeedTest.prototype;\n\nfn.module = function(name) {\n    return this._modules[name] || null;\n};\n\nfn.isRequesting = function() {\n    var modules = this._modules,\n        requesting = false;\n\n    for (var i in modules) {\n        if (modules.hasOwnProperty(i)) {\n            requesting = requesting || modules[i].isRequesting();\n        }\n    }\n\n    return requesting;\n};\n\nfn._setModule = function(name, object) {\n    var _this = this;\n\n    if (object) {\n        this._modules[name] = object.on('_newRequest', function() {\n            return !_this.isRequesting();\n        });\n    }\n\n    return this;\n};\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.SpeedTest = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar LatencyModule = require('./modules/latency'),\n    BandwidthModule = require('./modules/bandwidth');\n\nvar SpeedTest = module.exports = function(options) {\n    // Initialize the modules\n    this._modules = {};\n    this._setModule('latency', new LatencyModule(options))\n        ._setModule('upload', new BandwidthModule('upload', options))\n        ._setModule('download', new BandwidthModule('download', options));\n};\n\nvar fn = SpeedTest.prototype;\n\nfn.module = function(name) {\n    return this._modules[name] || null;\n};\n\nfn.isRequesting = function() {\n    var modules = this._modules,\n        requesting = false;\n\n    for (var i in modules) {\n        if (modules.hasOwnProperty(i)) {\n            requesting = requesting || modules[i].isRequesting();\n        }\n    }\n\n    return requesting;\n};\n\nfn._setModule = function(name, object) {\n    var _this = this;\n\n    if (object) {\n        this._modules[name] = object.on('_newRequest', function() {\n            return !_this.isRequesting();\n        });\n    }\n\n    return this;\n};\n\n},{\"./modules/bandwidth\":3,\"./modules/latency\":5}],2:[function(require,module,exports){\n'use strict';\n\nvar EventDispatcher = module.exports = function() {\n    this._events = {}; // Contains all the event callbacks, organized by event types.\n};\n\nvar fn = EventDispatcher.prototype;\n\nfn.on = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If inexistant, create the array used to store the callbacks.\n    if (!events) {\n        events = this._events[eventType] = [];\n    }\n\n    // If the callback isn't already registered, store it.\n    if (!~events.indexOf(callback)) {\n        events.push(callback);\n    }\n\n    return this;\n};\n\nfn.off = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If there is no specified callback, simply delete all the callbacks binded to the provided event type.\n    if (typeof callback == 'undefined' && events) {\n        delete this._events[eventType];\n    } else {\n        var eventIndex = events ? events.indexOf(callback) : -1;\n\n        // If the callback is registered, remove it from the array.\n        if (~eventIndex) {\n            events.splice(eventIndex, 1);\n        }\n    }\n\n    return this;\n};\n\nfn.trigger = function(eventType, extraParameters, context) {\n    var events = this._events[eventType] || [];\n    extraParameters = extraParameters || [];\n\n    // A callback can return a boolean value which will be logically compared to the other callbacks values before\n    // being returned by the trigger() method. This allows a callback to send a \"signal\" to the caller, like\n    // cancelling an action.\n    var returnValue = true;\n\n    events.forEach(function(callback) {\n        // A callback must explicitly return false if it wants the trigger() method to return false, undefined will\n        // not work. This avoids crappy callbacks to mess up with the triggering system.\n        var value = callback.apply(this, extraParameters);\n            value = value !== false ? true : false;\n\n        returnValue = returnValue && value; // Compare the result of the callback to the actual return value.\n    }, context);\n\n    return returnValue;\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar BandwidthModule = module.exports = function(loadingType, options) {\n    var validLoadingTypes = ['upload', 'download'];\n    loadingType = (~validLoadingTypes.indexOf(loadingType)) ? loadingType : 'download';\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        dataSize: {\n            upload: 2 * 1024 * 1024, // 2 MB\n            download: 10 * 1024 * 1024, // 10 MB\n            multiplier: 2\n        }\n    }, options);\n\n    // Call parent constructor.\n    HttpModule.call(this, loadingType, options);\n\n    // Define the object properties.\n    this._loadingType = loadingType;\n\n    this._intendedEnd = false;\n    this._isRestarting = false;\n\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n    this._avgSpeed = null;\n\n    this._requestID = 0;\n    this._progressID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        progress: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initBandwidthConfig();\n};\n\nvar fn = BandwidthModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    var loadingType = this._loadingType,\n        dataSize = this._options.dataSize,\n        reqID = this._requestID++;\n\n    this._intendedEnd = false;\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n\n    // Trigger the start event.\n    if (!this._isRestarting) {\n        this.trigger('start', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n    }\n\n    // Create unique timing labels for the new request.\n    var labels = this._timingLabels;\n    labels.start = loadingType +'-'+ reqID + '-start';\n    labels.progress = loadingType +'-'+ reqID + '-progress';\n    labels.end = loadingType +'-'+ reqID + '-end';\n    labels.measure = loadingType +'-'+ reqID + '-measure';\n\n    // Generate some random data to upload to the server. Here we're using a Blob instead of an ArrayBuffer because\n    // of a bug in Chrome (tested in v33.0.1750.146), causing a freeze of the page while trying to directly upload\n    // an ArrayBuffer (through an ArrayBufferView). The freeze lasts nearly 4.5s for 10MB of data. Using a Blob\n    // seems to solve the problem.\n    var blob = (loadingType == 'upload') ? new Blob([new ArrayBuffer(dataSize.upload)]) : null;\n\n    var type = (loadingType == 'download') ? 'GET' : 'POST';\n\n    // Initiate and send a new request.\n    this._newRequest(type, {\n        size: dataSize.download\n    })._sendRequest(blob);\n};\n\nfn.abort = function() {\n    this._intendedEnd = true;\n    return this._abort();\n};\n\nfn._initBandwidthConfig = function() {\n    var _this = this,\n        loadingType = this._loadingType,\n        eventsPrefix = (loadingType == 'upload') ? 'xhr-upload-' : 'xhr-';\n\n    this.on(eventsPrefix +'loadstart', function() {\n        Timing.mark(_this._timingLabels.start);\n    });\n\n    this.on(eventsPrefix +'progress', function(event) {\n        _this._progress(event);\n    });\n\n    this.on(eventsPrefix +'timeout', function() {\n        _this._timeout();\n    });\n\n    this.on(eventsPrefix +'loadend', function() {\n        _this._end();\n    });\n};\n\nfn._progress = function(event) {\n    var labels = this._timingLabels,\n        progressID = this._progressID++,\n        markLabel = labels.progress +'-'+ progressID,\n        loaded = event.loaded;\n\n    Timing.mark(markLabel);\n\n    // Measure the average speed (B/s) since the request started.\n    var avgMeasure = Timing.measure(\n            labels.measure +'-avg-'+ progressID,\n            labels.start,\n            markLabel\n        ),\n        avgSpeed = loaded / avgMeasure * 1000;\n\n    var instantSpeed;\n\n    if (!this._lastLoadedValue) { // We are executing the first progress event of the current request.\n        instantSpeed = avgSpeed; // The instant speed of the first progress event is equal to the average one.\n    } else {\n        // Measure the instant speed (B/s). Which defines the speed between two progress events.\n        var instantMeasure = Timing.measure(\n            labels.measure +'-instant-'+ progressID,\n            // Set the mark of the previous progress event as the starting point.\n            labels.progress +'-'+ (progressID - 1),\n            markLabel\n        );\n        instantSpeed = (loaded - this._lastLoadedValue) / instantMeasure * 1000;\n    }\n\n    // Save the `loaded` property of the event for the next progress event.\n    this._lastLoadedValue = loaded;\n\n    // Save the measures.\n    this._avgSpeed = avgSpeed;\n    this._speedRecords.push(instantSpeed);\n\n    this.trigger('progress', [avgSpeed, instantSpeed]);\n};\n\nfn._timeout = function() {\n    this._intendedEnd = true;\n};\n\nfn._end = function() {\n    // A timeout or an abort occured, bypass the further requests and trigger the \"end\" event.\n    if (this._intendedEnd) {\n        this._isRestarting = false;\n        this.trigger('end', [this._avgSpeed, this._speedRecords]);\n    }\n\n    // The request ended to early, restart it with an increased data size.\n    else {\n        var loadingType = this._loadingType,\n            dataSize = this._options.dataSize;\n\n        dataSize.upload *= dataSize.multiplier;\n        dataSize.download *= dataSize.multiplier;\n\n        this.trigger('restart', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n\n        this._isRestarting = true;\n        this.start();\n    }\n};\n\n},{\"../timing\":6,\"../utilities\":7,\"./http\":4}],4:[function(require,module,exports){\n'use strict';\n\nvar EventDispatcher = require('../event-dispatcher'),\n    Utilities = require('../utilities');\n\nvar HttpModule = module.exports = function(moduleName, options) {\n    // Call parent constructor.\n    EventDispatcher.call(this);\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        endpoint: './speedtest.php',\n        delay: 8000\n    }, options);\n\n    // Define the object properties.\n    this._options = options;\n    this._moduleName = moduleName;\n    this._xhr = null;\n    this._lastURLToken = null;\n\n    this._requestingOverridden = false;\n    this._requesting = false;\n\n    // Initiate the object.\n    this._initHttpConfig();\n};\n\nvar fn = HttpModule.prototype = Object.create(EventDispatcher.prototype);\n\nfn.isRequesting = function() {\n    return this._requesting;\n};\n\nfn._initHttpConfig = function() {\n    var _this = this;\n\n    // Each time a request starts or ends, set the requesting value unless it has been overridden with the\n    // _setRequesting() method.\n    var loadstart = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = true;\n        }\n    };\n\n    this.on('xhr-loadstart', loadstart);\n    this.on('xhr-upload-loadstart', loadstart);\n\n    var loadend = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = false;\n        }\n    };\n\n    this.on('xhr-loadend', loadend);\n    this.on('xhr-upload-loadend', loadend);\n};\n\nfn._newRequest = function(httpMethod, queryParams) {\n    // Check if a callback binded to the \"_newRequest\" event returns false, if it's the case, cancel the request\n    // creation. If the requesting status has been overridden, there's no need to cancel the request since the user\n    // should know what he's doing.\n    if (!this.trigger('_newRequest') && !this._requestingOverridden) {\n        console.warn('To ensure accurate measures, you can only make one request at a time.');\n        return this;\n    }\n\n    var _this = this,\n        options = this._options,\n        xhr = new XMLHttpRequest(),\n        validHttpMethods = ['GET', 'POST'];\n\n    // Prepare the new request.\n    if (!~validHttpMethods.indexOf(httpMethod)) {\n        console.warn('The HTTP method must be GET or POST.');\n        return this;\n    }\n\n    queryParams = queryParams || {};\n\n    // Generate an URL token to avoid any caching issues. This token will also allow to identify the request in the\n    // Resource Timing entries.\n    this._lastURLToken = 'speedtest-'+ (new Date).getTime();\n\n    // Append the query parameters.\n    var url = options.endpoint;\n        url += (~url.indexOf('?') ? '&' : '?') + 'module=' + this._moduleName;\n\n    Object.keys(queryParams).forEach(function(param) {\n        url += '&' + param + '=' + encodeURIComponent(queryParams[param]);\n    });\n\n    url += '&' + this._lastURLToken;\n\n    xhr.open(httpMethod, url);\n\n    // Define the timeout of the request.\n    xhr.timeout = options.delay;\n\n    // Abort the previous request if it hasn't been sent.\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.abort();\n    }\n\n    // Replace the old request by the new one.\n    this._xhr = xhr;\n\n    // Bind all the XHR events.\n    var eventTypes = ['loadstart', 'progress', 'abort', 'error', 'load', 'timeout', 'loadend', 'readystatechange'];\n\n    eventTypes.forEach(function(eventType) {\n        xhr.addEventListener(eventType, function() {\n            // A last progress event can be triggered once a request has timed out, ignore it.\n            if (eventType == 'progress' && !_this._requesting) {\n                return;\n            }\n\n            _this.trigger('xhr-'+ eventType, arguments, xhr);\n        });\n\n        // The XMLHttpRequestUpload interface supports all the above event types except the \"readystatechange\" one.\n        if (eventType != 'readystatechange') {\n            xhr.upload.addEventListener(eventType, function() {\n                _this.trigger('xhr-upload-'+ eventType, arguments, xhr);\n            });\n        }\n    });\n\n    return this;\n};\n\nfn._sendRequest = function(data) {\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.send(typeof data != 'undefined' ? data : null);\n    } else {\n        console.warn('A request must have been created before it can be sent.');\n    }\n\n    return this;\n};\n\nfn._abort = function() {\n    if (this._xhr) {\n        this._xhr.abort();\n    }\n\n    return this;\n};\n\nfn._getTimingEntry = function(callback) {\n    // The Resource Timing entries aren't immediately available once the 'load' event is triggered by an\n    // XMLHttpRequest, we must wait for another process tick to check for a refreshed list.\n    setTimeout((function(lastURLToken) {\n        return function() {\n            // Filter the timing entries to return only the one concerned by the last request made.\n            var entries = performance.getEntriesByType('resource').filter(function(entry) {\n                return ~entry.name.indexOf(lastURLToken);\n            });\n\n            // Return the entry through the callback.\n            typeof callback == 'function' && callback(entries.length ? entries[0] : null);\n        };\n    })(this._lastURLToken), 0);\n\n    return this;\n};\n\nfn._setRequesting = function(value) {\n    this._requestingOverridden = true;\n    this._requesting = value;\n};\n\n},{\"../event-dispatcher\":2,\"../utilities\":7}],5:[function(require,module,exports){\n'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar LatencyModule = module.exports = function(options) {\n    // We dont want any timeout during a latency calculation. Here we are using extend() because we want to edit the\n    // delay on a clone of the object and not the original one.\n    options = Utilities.extend(options, {\n        delay: 0\n    });\n\n    // Call parent constructor.\n    HttpModule.call(this, 'latency', options);\n\n    // Define the object properties.\n    this._requestsLeft = 0;\n    this._latencies = [];\n    this._requestID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initLatencyConfig();\n};\n\nvar fn = LatencyModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    // Set the number of requests required to establish the network latency. If the browser doesn't support the\n    // Resource Timing API, add a request that will be ignored to avoid a longer request due to a possible\n    // DNS/whatever fetch.\n    this._requestsLeft = 5;\n    Timing.supportsResourceTiming() || this._requestsLeft++;\n\n    // Override the requesting value since a complete latency request consists off multiple ones.\n    this._setRequesting(true);\n\n    this._latencies = [];\n    this._nextRequest();\n\n    return this;\n};\n\nfn._initLatencyConfig = function() {\n    var _this = this;\n\n    // Calculate the latency with the Resource Timing API once the request is finished.\n    if (Timing.supportsResourceTiming()) {\n        this.on('xhr-load', function() {\n            _this._getTimingEntry(function(entry) {\n                // The latency calculation differs between an HTTP and an HTTPS connection.\n                // See: http://www.w3.org/TR/resource-timing/#processing-model\n                var latency = !entry.secureConnectionStart\n                                ? entry.connectEnd - entry.connectStart\n                                : entry.secureConnectionStart - entry.connectStart;\n\n                _this._latencies.push(latency);\n            });\n        });\n    }\n\n    // If the browser doesn't support the Resource Timing API, we fallback on a Datetime solution.\n    else {\n        var labels = this._timingLabels;\n\n        // Set a mark when the request starts.\n        this.on('xhr-loadstart', function() {\n            Timing.mark(labels.start);\n        });\n\n        this.on('xhr-readystatechange', function() {\n            // Ignore the first request (see the comments in the start() method) and calculate the latency if the\n            // headers have been received.\n            if (_this._requestsLeft < 5 && this.readyState == XMLHttpRequest.HEADERS_RECEIVED) {\n                // Save the timing measure.\n                Timing.mark(labels.end);\n                _this._latencies.push(Timing.measure(labels.measure, labels.start, labels.end));\n            }\n        });\n    }\n\n    this.on('xhr-load', function() {\n        // An anonymous callback is required to avoid the `this` key to be defined as the XHR object.\n        _this._nextRequest();\n    });\n};\n\nfn._nextRequest = function() {\n    if (this._requestsLeft--) {\n        var reqID = this._requestID++;\n\n        // Create unique timing labels for the new request.\n        var labels = this._timingLabels;\n        labels.start = 'latency-'+ reqID + '-start';\n        labels.end = 'latency-'+ reqID + '-end';\n        labels.measure = 'latency-'+ reqID + '-measure';\n\n        // Create the new request and send it.\n        this._newRequest('GET')._sendRequest();\n    } else {\n        var _this = this;\n\n        // All the requests are finished, set the requesting status to false.\n        this._setRequesting(false);\n\n        // If all the requests have been executed, calculate the average latency. Since the _getTimingEntry() method\n        // is asynchronous, wait for the next process tick to execute the _calculate() method, to be sure that all\n        // the latencies have been retrieved.\n        setTimeout(function() {\n            _this._calculate();\n        }, 0);\n    }\n};\n\nfn._calculate = function() {\n    var latencies = this._latencies,\n        isThereAnyZeroLatency = false;\n\n    // Get the average latency.\n    var avgLatency = latencies.reduce(function(a, b) {\n        // Check if there is any latency equal to zero.\n        isThereAnyZeroLatency = isThereAnyZeroLatency || (a == 0 || b == 0);\n        // Sum the current latency to the previous value.\n        return a + b;\n    }) / latencies.length;\n\n    // If there is any zero latency, display a warning.\n    isThereAnyZeroLatency && console.warn([\n        'At least one latency returned a zero value, this can be due to the configuration of your web server which',\n        'is probably using persistant connections. Check the documentation to solve this problem.'\n    ].join(' '));\n\n    // Trigger the \"end\" event with the average latency and the latency list as parameters.\n    this.trigger('end', [avgLatency, latencies]);\n};\n\n},{\"../timing\":6,\"../utilities\":7,\"./http\":4}],6:[function(require,module,exports){\n'use strict';\n\nvar Timing = module.exports = function() {};\n\nvar staticScope = Timing;\n\nstaticScope._marks = {};\nstaticScope._measures = {};\n\n// Does the browser support the following APIs?\nstaticScope._support = {\n    performance: !!window.performance,\n    userTiming: window.performance && performance.mark,\n    resourceTiming: window.performance && (typeof(performance.getEntriesByType) == \"function\") && performance.timing\n};\n\nstaticScope.mark = function(label) {\n    var support = this._support,\n        marks = this._marks;\n\n    if (support.userTiming) {\n        performance.mark(label);\n    } else if (support.performance) {\n        marks[label] = performance.now();\n    } else {\n        marks[label] = (new Date).getTime();\n    }\n\n    return this;\n};\n\nstaticScope.measure = function(measureLabel, markLabelA, markLabelB) {\n    var support = this._support,\n        marks = this._marks,\n        measures = this._measures;\n\n    if (typeof measures[measureLabel] == 'undefined') {\n        if (support.userTiming) {\n            performance.measure(measureLabel, markLabelA, markLabelB);\n            measures[measureLabel] = performance.getEntriesByName(measureLabel)[0].duration;\n        } else {\n            measures[measureLabel] = marks[markLabelB] - marks[markLabelA];\n        }\n    }\n\n    return measures[measureLabel];\n};\n\nstaticScope.supportsResourceTiming = function() {\n    return this._support.resourceTiming;\n};\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nfunction extend(destination, source) {\n    // Deep clone the objects to avoid any module to modify options of another module.\n    // See: http://stackoverflow.com/a/5344074/1513045\n    destination = JSON.parse(JSON.stringify(destination || {}));\n    source = JSON.parse(JSON.stringify(source || {}));\n\n    // Apply source values on the destination object.\n    Object.keys(source).forEach(function(key) {\n        destination[key] = source[key];\n    });\n\n    return destination;\n}\n\nexports.extend = extend;\n\n},{}]},{},[1])(1)\n});\n\n\n//# sourceMappingURL=speedtest.js.map","'use strict';\n\nvar EventDispatcher = module.exports = function() {\n    this._events = {}; // Contains all the event callbacks, organized by event types.\n};\n\nvar fn = EventDispatcher.prototype;\n\nfn.on = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If inexistant, create the array used to store the callbacks.\n    if (!events) {\n        events = this._events[eventType] = [];\n    }\n\n    // If the callback isn't already registered, store it.\n    if (!~events.indexOf(callback)) {\n        events.push(callback);\n    }\n\n    return this;\n};\n\nfn.off = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If there is no specified callback, simply delete all the callbacks binded to the provided event type.\n    if (typeof callback == 'undefined' && events) {\n        delete this._events[eventType];\n    } else {\n        var eventIndex = events ? events.indexOf(callback) : -1;\n\n        // If the callback is registered, remove it from the array.\n        if (~eventIndex) {\n            events.splice(eventIndex, 1);\n        }\n    }\n\n    return this;\n};\n\nfn.trigger = function(eventType, extraParameters, context) {\n    var events = this._events[eventType] || [];\n    extraParameters = extraParameters || [];\n\n    // A callback can return a boolean value which will be logically compared to the other callbacks values before\n    // being returned by the trigger() method. This allows a callback to send a \"signal\" to the caller, like\n    // cancelling an action.\n    var returnValue = true;\n\n    events.forEach(function(callback) {\n        // A callback must explicitly return false if it wants the trigger() method to return false, undefined will\n        // not work. This avoids crappy callbacks to mess up with the triggering system.\n        var value = callback.apply(this, extraParameters);\n            value = value !== false ? true : false;\n\n        returnValue = returnValue && value; // Compare the result of the callback to the actual return value.\n    }, context);\n\n    return returnValue;\n};\n","'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar BandwidthModule = module.exports = function(loadingType, options) {\n    var validLoadingTypes = ['upload', 'download'];\n    loadingType = (~validLoadingTypes.indexOf(loadingType)) ? loadingType : 'download';\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        dataSize: {\n            upload: 2 * 1024 * 1024, // 2 MB\n            download: 10 * 1024 * 1024, // 10 MB\n            multiplier: 2\n        }\n    }, options);\n\n    // Call parent constructor.\n    HttpModule.call(this, loadingType, options);\n\n    // Define the object properties.\n    this._loadingType = loadingType;\n\n    this._intendedEnd = false;\n    this._isRestarting = false;\n\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n    this._avgSpeed = null;\n\n    this._requestID = 0;\n    this._progressID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        progress: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initBandwidthConfig();\n};\n\nvar fn = BandwidthModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    var loadingType = this._loadingType,\n        dataSize = this._options.dataSize,\n        reqID = this._requestID++;\n\n    this._intendedEnd = false;\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n\n    // Trigger the start event.\n    if (!this._isRestarting) {\n        this.trigger('start', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n    }\n\n    // Create unique timing labels for the new request.\n    var labels = this._timingLabels;\n    labels.start = loadingType +'-'+ reqID + '-start';\n    labels.progress = loadingType +'-'+ reqID + '-progress';\n    labels.end = loadingType +'-'+ reqID + '-end';\n    labels.measure = loadingType +'-'+ reqID + '-measure';\n\n    // Generate some random data to upload to the server. Here we're using a Blob instead of an ArrayBuffer because\n    // of a bug in Chrome (tested in v33.0.1750.146), causing a freeze of the page while trying to directly upload\n    // an ArrayBuffer (through an ArrayBufferView). The freeze lasts nearly 4.5s for 10MB of data. Using a Blob\n    // seems to solve the problem.\n    var blob = (loadingType == 'upload') ? new Blob([new ArrayBuffer(dataSize.upload)]) : null;\n\n    var type = (loadingType == 'download') ? 'GET' : 'POST';\n\n    // Initiate and send a new request.\n    this._newRequest(type, {\n        size: dataSize.download\n    })._sendRequest(blob);\n};\n\nfn.abort = function() {\n    this._intendedEnd = true;\n    return this._abort();\n};\n\nfn._initBandwidthConfig = function() {\n    var _this = this,\n        loadingType = this._loadingType,\n        eventsPrefix = (loadingType == 'upload') ? 'xhr-upload-' : 'xhr-';\n\n    this.on(eventsPrefix +'loadstart', function() {\n        Timing.mark(_this._timingLabels.start);\n    });\n\n    this.on(eventsPrefix +'progress', function(event) {\n        _this._progress(event);\n    });\n\n    this.on(eventsPrefix +'timeout', function() {\n        _this._timeout();\n    });\n\n    this.on(eventsPrefix +'loadend', function() {\n        _this._end();\n    });\n};\n\nfn._progress = function(event) {\n    var labels = this._timingLabels,\n        progressID = this._progressID++,\n        markLabel = labels.progress +'-'+ progressID,\n        loaded = event.loaded;\n\n    Timing.mark(markLabel);\n\n    // Measure the average speed (B/s) since the request started.\n    var avgMeasure = Timing.measure(\n            labels.measure +'-avg-'+ progressID,\n            labels.start,\n            markLabel\n        ),\n        avgSpeed = loaded / avgMeasure * 1000;\n\n    var instantSpeed;\n\n    if (!this._lastLoadedValue) { // We are executing the first progress event of the current request.\n        instantSpeed = avgSpeed; // The instant speed of the first progress event is equal to the average one.\n    } else {\n        // Measure the instant speed (B/s). Which defines the speed between two progress events.\n        var instantMeasure = Timing.measure(\n            labels.measure +'-instant-'+ progressID,\n            // Set the mark of the previous progress event as the starting point.\n            labels.progress +'-'+ (progressID - 1),\n            markLabel\n        );\n        instantSpeed = (loaded - this._lastLoadedValue) / instantMeasure * 1000;\n    }\n\n    // Save the `loaded` property of the event for the next progress event.\n    this._lastLoadedValue = loaded;\n\n    // Save the measures.\n    this._avgSpeed = avgSpeed;\n    this._speedRecords.push(instantSpeed);\n\n    this.trigger('progress', [avgSpeed, instantSpeed]);\n};\n\nfn._timeout = function() {\n    this._intendedEnd = true;\n};\n\nfn._end = function() {\n    // A timeout or an abort occured, bypass the further requests and trigger the \"end\" event.\n    if (this._intendedEnd) {\n        this._isRestarting = false;\n        this.trigger('end', [this._avgSpeed, this._speedRecords]);\n    }\n\n    // The request ended to early, restart it with an increased data size.\n    else {\n        var loadingType = this._loadingType,\n            dataSize = this._options.dataSize;\n\n        dataSize.upload *= dataSize.multiplier;\n        dataSize.download *= dataSize.multiplier;\n\n        this.trigger('restart', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n\n        this._isRestarting = true;\n        this.start();\n    }\n};\n","'use strict';\n\nvar EventDispatcher = require('../event-dispatcher'),\n    Utilities = require('../utilities');\n\nvar HttpModule = module.exports = function(moduleName, options) {\n    // Call parent constructor.\n    EventDispatcher.call(this);\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        endpoint: './speedtest.php',\n        delay: 8000\n    }, options);\n\n    // Define the object properties.\n    this._options = options;\n    this._moduleName = moduleName;\n    this._xhr = null;\n    this._lastURLToken = null;\n\n    this._requestingOverridden = false;\n    this._requesting = false;\n\n    // Initiate the object.\n    this._initHttpConfig();\n};\n\nvar fn = HttpModule.prototype = Object.create(EventDispatcher.prototype);\n\nfn.isRequesting = function() {\n    return this._requesting;\n};\n\nfn._initHttpConfig = function() {\n    var _this = this;\n\n    // Each time a request starts or ends, set the requesting value unless it has been overridden with the\n    // _setRequesting() method.\n    var loadstart = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = true;\n        }\n    };\n\n    this.on('xhr-loadstart', loadstart);\n    this.on('xhr-upload-loadstart', loadstart);\n\n    var loadend = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = false;\n        }\n    };\n\n    this.on('xhr-loadend', loadend);\n    this.on('xhr-upload-loadend', loadend);\n};\n\nfn._newRequest = function(httpMethod, queryParams) {\n    // Check if a callback binded to the \"_newRequest\" event returns false, if it's the case, cancel the request\n    // creation. If the requesting status has been overridden, there's no need to cancel the request since the user\n    // should know what he's doing.\n    if (!this.trigger('_newRequest') && !this._requestingOverridden) {\n        console.warn('To ensure accurate measures, you can only make one request at a time.');\n        return this;\n    }\n\n    var _this = this,\n        options = this._options,\n        xhr = new XMLHttpRequest(),\n        validHttpMethods = ['GET', 'POST'];\n\n    // Prepare the new request.\n    if (!~validHttpMethods.indexOf(httpMethod)) {\n        console.warn('The HTTP method must be GET or POST.');\n        return this;\n    }\n\n    queryParams = queryParams || {};\n\n    // Generate an URL token to avoid any caching issues. This token will also allow to identify the request in the\n    // Resource Timing entries.\n    this._lastURLToken = 'speedtest-'+ (new Date).getTime();\n\n    // Append the query parameters.\n    var url = options.endpoint;\n        url += (~url.indexOf('?') ? '&' : '?') + 'module=' + this._moduleName;\n\n    Object.keys(queryParams).forEach(function(param) {\n        url += '&' + param + '=' + encodeURIComponent(queryParams[param]);\n    });\n\n    url += '&' + this._lastURLToken;\n\n    xhr.open(httpMethod, url);\n\n    // Define the timeout of the request.\n    xhr.timeout = options.delay;\n\n    // Abort the previous request if it hasn't been sent.\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.abort();\n    }\n\n    // Replace the old request by the new one.\n    this._xhr = xhr;\n\n    // Bind all the XHR events.\n    var eventTypes = ['loadstart', 'progress', 'abort', 'error', 'load', 'timeout', 'loadend', 'readystatechange'];\n\n    eventTypes.forEach(function(eventType) {\n        xhr.addEventListener(eventType, function() {\n            // A last progress event can be triggered once a request has timed out, ignore it.\n            if (eventType == 'progress' && !_this._requesting) {\n                return;\n            }\n\n            _this.trigger('xhr-'+ eventType, arguments, xhr);\n        });\n\n        // The XMLHttpRequestUpload interface supports all the above event types except the \"readystatechange\" one.\n        if (eventType != 'readystatechange') {\n            xhr.upload.addEventListener(eventType, function() {\n                _this.trigger('xhr-upload-'+ eventType, arguments, xhr);\n            });\n        }\n    });\n\n    return this;\n};\n\nfn._sendRequest = function(data) {\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.send(typeof data != 'undefined' ? data : null);\n    } else {\n        console.warn('A request must have been created before it can be sent.');\n    }\n\n    return this;\n};\n\nfn._abort = function() {\n    if (this._xhr) {\n        this._xhr.abort();\n    }\n\n    return this;\n};\n\nfn._getTimingEntry = function(callback) {\n    // The Resource Timing entries aren't immediately available once the 'load' event is triggered by an\n    // XMLHttpRequest, we must wait for another process tick to check for a refreshed list.\n    setTimeout((function(lastURLToken) {\n        return function() {\n            // Filter the timing entries to return only the one concerned by the last request made.\n            var entries = performance.getEntriesByType('resource').filter(function(entry) {\n                return ~entry.name.indexOf(lastURLToken);\n            });\n\n            // Return the entry through the callback.\n            typeof callback == 'function' && callback(entries.length ? entries[0] : null);\n        };\n    })(this._lastURLToken), 0);\n\n    return this;\n};\n\nfn._setRequesting = function(value) {\n    this._requestingOverridden = true;\n    this._requesting = value;\n};\n","'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar LatencyModule = module.exports = function(options) {\n    // We dont want any timeout during a latency calculation. Here we are using extend() because we want to edit the\n    // delay on a clone of the object and not the original one.\n    options = Utilities.extend(options, {\n        delay: 0\n    });\n\n    // Call parent constructor.\n    HttpModule.call(this, 'latency', options);\n\n    // Define the object properties.\n    this._requestsLeft = 0;\n    this._latencies = [];\n    this._requestID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initLatencyConfig();\n};\n\nvar fn = LatencyModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    // Set the number of requests required to establish the network latency. If the browser doesn't support the\n    // Resource Timing API, add a request that will be ignored to avoid a longer request due to a possible\n    // DNS/whatever fetch.\n    this._requestsLeft = 5;\n    Timing.supportsResourceTiming() || this._requestsLeft++;\n\n    // Override the requesting value since a complete latency request consists off multiple ones.\n    this._setRequesting(true);\n\n    this._latencies = [];\n    this._nextRequest();\n\n    return this;\n};\n\nfn._initLatencyConfig = function() {\n    var _this = this;\n\n    // Calculate the latency with the Resource Timing API once the request is finished.\n    if (Timing.supportsResourceTiming()) {\n        this.on('xhr-load', function() {\n            _this._getTimingEntry(function(entry) {\n                // The latency calculation differs between an HTTP and an HTTPS connection.\n                // See: http://www.w3.org/TR/resource-timing/#processing-model\n                var latency = !entry.secureConnectionStart\n                                ? entry.connectEnd - entry.connectStart\n                                : entry.secureConnectionStart - entry.connectStart;\n\n                _this._latencies.push(latency);\n            });\n        });\n    }\n\n    // If the browser doesn't support the Resource Timing API, we fallback on a Datetime solution.\n    else {\n        var labels = this._timingLabels;\n\n        // Set a mark when the request starts.\n        this.on('xhr-loadstart', function() {\n            Timing.mark(labels.start);\n        });\n\n        this.on('xhr-readystatechange', function() {\n            // Ignore the first request (see the comments in the start() method) and calculate the latency if the\n            // headers have been received.\n            if (_this._requestsLeft < 5 && this.readyState == XMLHttpRequest.HEADERS_RECEIVED) {\n                // Save the timing measure.\n                Timing.mark(labels.end);\n                _this._latencies.push(Timing.measure(labels.measure, labels.start, labels.end));\n            }\n        });\n    }\n\n    this.on('xhr-load', function() {\n        // An anonymous callback is required to avoid the `this` key to be defined as the XHR object.\n        _this._nextRequest();\n    });\n};\n\nfn._nextRequest = function() {\n    if (this._requestsLeft--) {\n        var reqID = this._requestID++;\n\n        // Create unique timing labels for the new request.\n        var labels = this._timingLabels;\n        labels.start = 'latency-'+ reqID + '-start';\n        labels.end = 'latency-'+ reqID + '-end';\n        labels.measure = 'latency-'+ reqID + '-measure';\n\n        // Create the new request and send it.\n        this._newRequest('GET')._sendRequest();\n    } else {\n        var _this = this;\n\n        // All the requests are finished, set the requesting status to false.\n        this._setRequesting(false);\n\n        // If all the requests have been executed, calculate the average latency. Since the _getTimingEntry() method\n        // is asynchronous, wait for the next process tick to execute the _calculate() method, to be sure that all\n        // the latencies have been retrieved.\n        setTimeout(function() {\n            _this._calculate();\n        }, 0);\n    }\n};\n\nfn._calculate = function() {\n    var latencies = this._latencies,\n        isThereAnyZeroLatency = false;\n\n    // Get the average latency.\n    var avgLatency = latencies.reduce(function(a, b) {\n        // Check if there is any latency equal to zero.\n        isThereAnyZeroLatency = isThereAnyZeroLatency || (a == 0 || b == 0);\n        // Sum the current latency to the previous value.\n        return a + b;\n    }) / latencies.length;\n\n    // If there is any zero latency, display a warning.\n    isThereAnyZeroLatency && console.warn([\n        'At least one latency returned a zero value, this can be due to the configuration of your web server which',\n        'is probably using persistant connections. Check the documentation to solve this problem.'\n    ].join(' '));\n\n    // Trigger the \"end\" event with the average latency and the latency list as parameters.\n    this.trigger('end', [avgLatency, latencies]);\n};\n","'use strict';\n\nvar Timing = module.exports = function() {};\n\nvar staticScope = Timing;\n\nstaticScope._marks = {};\nstaticScope._measures = {};\n\n// Does the browser support the following APIs?\nstaticScope._support = {\n    performance: !!window.performance,\n    userTiming: window.performance && performance.mark,\n    resourceTiming: window.performance && (typeof(performance.getEntriesByType) == \"function\") && performance.timing\n};\n\nstaticScope.mark = function(label) {\n    var support = this._support,\n        marks = this._marks;\n\n    if (support.userTiming) {\n        performance.mark(label);\n    } else if (support.performance) {\n        marks[label] = performance.now();\n    } else {\n        marks[label] = (new Date).getTime();\n    }\n\n    return this;\n};\n\nstaticScope.measure = function(measureLabel, markLabelA, markLabelB) {\n    var support = this._support,\n        marks = this._marks,\n        measures = this._measures;\n\n    if (typeof measures[measureLabel] == 'undefined') {\n        if (support.userTiming) {\n            performance.measure(measureLabel, markLabelA, markLabelB);\n            measures[measureLabel] = performance.getEntriesByName(measureLabel)[0].duration;\n        } else {\n            measures[measureLabel] = marks[markLabelB] - marks[markLabelA];\n        }\n    }\n\n    return measures[measureLabel];\n};\n\nstaticScope.supportsResourceTiming = function() {\n    return this._support.resourceTiming;\n};\n","'use strict';\n\nfunction extend(destination, source) {\n    // Deep clone the objects to avoid any module to modify options of another module.\n    // See: http://stackoverflow.com/a/5344074/1513045\n    destination = JSON.parse(JSON.stringify(destination || {}));\n    source = JSON.parse(JSON.stringify(source || {}));\n\n    // Apply source values on the destination object.\n    Object.keys(source).forEach(function(key) {\n        destination[key] = source[key];\n    });\n\n    return destination;\n}\n\nexports.extend = extend;\n"],"sourceRoot":"/source/"}